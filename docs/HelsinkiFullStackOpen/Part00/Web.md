This is a transcription of the webpage "Fundamentals of Web Apps" from the Full Stack Open course.

---

# ( ) -> { } About course Course contents FAQ Partners Challenge [Search Icon] English [Dropdown]

**Fullstack** > **Part 0** > **Fundamentals of Web apps**

---

## b Fundamentals of Web apps

*   **a General info**
*   **b Fundamentals of Web apps**
    *   Traditional web applications
    *   Running application logic in the browser
    *   Event handlers and Callback functions
    *   Document Object Model or DOM
    *   Manipulating the document object from console
    *   CSS
    *   Loading a page containing JavaScript - review
    *   Forms and HTTP POST
    *   AJAX
    *   Single page app
    *   JavaScript-libraries
    *   Full-stack web development
    *   JavaScript fatigue
    *   Exercises 0.1.-0.6.

Before we start programming, we will go through some basic principles of web development by examining an example application at [https://studies.cs.helsinki.fi/exampleapp](https://studies.cs.helsinki.fi/exampleapp).

The example app is only there to demonstrate some basic concepts of the course, and is, by no means, an example of how a modern web application should be made. On the contrary, it illustrates some older techniques of web development, which could even be considered bad practices nowadays.

Code will conform to contemporary best practices from part 1 onwards.

Open the example application in your browser. Sometimes this takes a while.

The material was done with and optimized for the Chrome browser.

**The 1st rule of web development**: Always keep the Developer console open on your web browser. On macOS, press `F12` or `option-cmd-i`. On Windows or Linux, press `F12` or `ctrl-shift-i`.

Remember to always keep the Developer console open when developing web applications.

The console looks like this:

![Screenshot of the example app with developer tools open showing the Network tab.]

Make sure that the Network tab is open, and check the **Disable cache** option as shown. **Preserve log** can also be useful: it saves the logs generated by the application when the page is reloaded. **Note**: the Network tab shows HTTP requests of any extensions installed in the browser. These can be hidden with the Filter.

**NB**: The most important tab is the Console tab. However, in this introduction, we will be using the Network tab a lot.

### HTTP GET

The server and the web browser communicate with each other using the HTTP protocol. The Network tab shows how the browser and the server communicate.

When you reload the page (`F5` refresh on a webpage, on Windows, press the `F5` key, on macOS, press `command + r`), the browser will communicate with the server. In the console, you will see that events have happened:

*   The browser has fetched the contents of the page studies.cs.helsinki.fi/exampleapp from the server
*   And has downloaded the image kuva.png

![Screenshot of Network tab showing requests for exampleapp and kuva.png.]

On a small screen, you might have to widen the console window to see these.

Clicking the first request shows more information about it:

![Screenshot of request details for exampleapp showing General, Response Headers, and Request Headers.]

The upper part, **General**, shows that the browser requested the address [https://studies.cs.helsinki.fi/exampleapp](https://studies.cs.helsinki.fi/exampleapp) using the **GET** method, and that the request was successful, because the server response had the **Status Code 200 OK**.

The request and the server response have several **headers**:

![Screenshot showing Response Headers (Connection, Content-Length, Content-Type, Date) and Request Headers (Accept, Accept-Encoding, etc.).]

The **Response headers** on top tell us e.g. the size of the response in bytes and the exact time of the response. An important header is **Content-Type**, which tells us that the response is a text file in utf-8 format and the contents of which have been formatted with HTML. This way the browser knows that the response is a regular HTML page and to render it to the browser like a web page.

The **Response** tab shows the response data, a regular HTML page. The body section determines the structure of the page rendered to the screen:

![Screenshot of the Response tab showing HTML code with a div, h1, a, p, and img tag.]

The page contains a div element, which in turn contains a heading, a link to the page notes, and an img tag, and displays the number of notes created.

Because of the img tag, the browser does a second HTTP request to fetch the image kuva.png from the server. The details of the request are as follows:

![Screenshot of request details for kuva.png showing Status Code 200 OK and Content-Type: image/png.]

The request was made to the address [https://studies.cs.helsinki.fi/exampleapp/kuva.png](https://studies.cs.helsinki.fi/exampleapp/kuva.png) and its type is HTTP GET. The response headers tell us that the response size is 89350 bytes, and its Content-Type is image/png. The browser uses this information to render the image correctly to the screen.

The chain of events caused by opening the page [https://studies.cs.helsinki.fi/exampleapp](https://studies.cs.helsinki.fi/exampleapp) on a browser forms the following sequence diagram:

![Sequence diagram showing: 1. Browser GET /exampleapp -> Server. 2. Server -> Browser HTML document. 3. Browser GET /kuva.png -> Server. 4. Server -> Browser kuva.png.]

The sequence diagram visualizes how the browser and server are communicating over the time. Time flows in the diagram from top to bottom, so the diagram starts with the first event on top, and the last event is at the bottom.

First, the browser sends an HTTP GET request to the server to fetch the HTML code of the page. The img tag in the HTML causes the browser to fetch the image kuva.png. The browser renders the HTML page and the image to the screen.

Even though it's difficult to notice, the HTML page begins to render before the image has been fetched from the server.

### Traditional web applications

The example app works like a traditional web application. When entering the page, the browser fetches the HTML document detailing the structure and the textual content of the page from the server.

The server has formed this document somehow. The document can be a static text file saved in the server's directory. The server can also form the HTML documents dynamically according to the application code, using, for example, data from a database. The HTML code of the example application has been formed dynamically because it contains information on the number of existing notes.

The HTML code of the homepage is formed dynamically on the server as follows:

```javascript
const getFrontPageHtml = (noteCount) => {
  return `
<!DOCTYPE html>
<html>
<head>
</head>
<body>
  <div class='container'>
    <h1>Notes</h1>
    <a href='/notes'>notes</a>
    <p id='number_of_notes'>
      number of notes created ${noteCount}
    </p>
    <img src='kuva.png' width='200' />
  </div>
</body>
</html>
`
}

app.get('/', (req, res) => {
  const page = getFrontPageHtml(notes.length)
  res.send(page)
})
```

You don't have to understand the code just yet.

The content of the HTML page has been saved as a template string or a string that allows for evaluating, for example, variables, like `noteCount`, in the middle of it. The dynamically changing part of the homepage, the number of saved notes (in the code `notes.length`), is replaced by the current number of notes in the code: `notes.length` in the template string.

Writing HTML within the code is of course not smart, but for old-school PHP programmers, it was a normal practice.

In traditional web applications, the browser is "dumb". It only fetches HTML data from the server, and all application logic is on the server. A server can be created using Java Spring, Python Django, Ruby on Rails, or Node.js to name a few examples.

The example uses Express library with Node.js. This course will use Node.js and Express to create web servers.

### Running application logic in the browser

Keep the Developer Console open. Empty the console by clicking the ðŸš« symbol, or by typing `clear()` in the console. Now when you open the notes page, the browser does 4 HTTP requests:

![Screenshot of Network tab showing 4 requests: notes (document), main.css (stylesheet), main.js (script), and data.json (fetch).]

All of the requests have different types. The first request's type is document. It is the HTML code of the page, and it looks as follows:

![Screenshot of Response tab for the notes request showing HTML code with a script tag for main.js.]

When we compare the page shown on the browser and the HTML code returned by the server, we notice that the code does not contain the list of notes. The head section of the HTML contains a script tag, which causes the browser to fetch a JavaScript file called main.js.

The JavaScript code looks as follows:

```javascript
var xhttp = new XMLHttpRequest();

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText);
    console.log(data);

    var ul = document.createElement('ul');
    ul.setAttribute('class', 'notes');

    data.forEach(function(note) {
      var li = document.createElement('li');

      li.appendChild(document.createTextNode(note.content));
      ul.appendChild(li);
    });

    document.getElementById('notes').appendChild(ul);
  }
};

xhttp.open('GET', '/data.json', true);
xhttp.send();
```

The details of the code are not important right now, but some code has been included to spice things up. We will start with real coding in part 1. The sample code in this part is actually not relevant at all to the coding techniques of this course.

*   **NB**: The code above is written using an older style of JavaScript. This is due to not wanting to go into promises at part 0, and the code having a secondary role in this part. We will return to modern ways of making requests in the browser in part 2.

Immediately after fetching the script tag, the browser begins to execute the code.

The last two lines instruct the browser to do an HTTP GET request to the server's address /data.json:

```javascript
xhttp.open('GET', '/data.json', true);
xhttp.send();
```

This is the bottom-most request shown on the Network tab.

We can try to go to the address [https://studies.cs.helsinki.fi/exampleapp/data.json](https://studies.cs.helsinki.fi/exampleapp/data.json) straight from the browser:

![Screenshot of browser showing raw JSON data.]

There we find the notes in "raw data" in JSON format. By default, Chromium-based browsers are not too good at displaying JSON data. Plugins can be used to handle the formatting. Install, for example, JSONView to Chrome.

![Screenshot of browser showing formatted JSON data.]

So, the JavaScript code of the notes page above downloads the JSON data containing the notes and forms a bulleted list from the note contents.

This is done by the following code:

```javascript
const data = JSON.parse(this.responseText);
console.log(data);

var ul = document.createElement('ul');
ul.setAttribute('class', 'notes');

data.forEach(function(note) {
  var li = document.createElement('li');

  li.appendChild(document.createTextNode(note.content));
  ul.appendChild(li);
});

document.getElementById('notes').appendChild(ul);
```

The code first creates an unordered list with a `ul` tag...

```javascript
var ul = document.createElement('ul');
ul.setAttribute('class', 'notes');
```

...and then adds one `li` tag for each note. Only the content field of each note becomes the textual content of the `li` tag. The timestamps in the raw data are not used for anything here.

```javascript
data.forEach(function(note) {
  var li = document.createElement('li');

  li.appendChild(document.createTextNode(note.content));
  ul.appendChild(li);
});
```

Now open the Console tab on your Developer Console:

![Screenshot of Console tab showing an array of 100 objects.]

By clicking the little triangle at the beginning of the line, you can expand the text on the console.

![Screenshot of expanded object in Console showing content and date fields.]

This output on the console is caused by the `console.log` command in the code:

```javascript
const data = JSON.parse(this.responseText);
console.log(data);
```

So, after receiving data from the server, the code prints it to the console.

The Console tab and the `console.log` command will become very familiar to you during the course.

### Event handlers and Callback functions

The structure of the code is a bit odd:

```javascript
var xhttp = new XMLHttpRequest();

xhttp.onreadystatechange = function() {
  // code that takes care of the server response
};

xhttp.open('GET', '/data.json', true);
xhttp.send();
```

The request to the server is sent on the last line, but the code to handle the response can be found further up.

```javascript
xhttp.onreadystatechange = function() {
  // code that takes care of the server response
};
```

On this line, an event handler for the event `onreadystatechange` is defined for the `xhttp` object doing the request. When the state of the object changes, the browser calls the event handler function. The function code checks that the `readyState` equals 4 (which depicts the situation The operation is complete) and that the HTTP status code of the response is 200.

```javascript
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    // code that takes care of the server response
  }
};
```

The mechanism of invoking event handlers is very common in JavaScript. Event handler functions are called **callback functions**. The application code does not invoke the functions itself, but the runtime environment - the browser - invokes the function at an appropriate time when the event has occurred.

### Document Object Model or DOM

We can think of HTML pages as implicit tree structures.

![Diagram of a DOM tree with html at the root, branching into head and body, and further into script, link, div, h1, a, p, img, and input.]

The same tree-like structure can be seen on the console's Elements tab.

![Screenshot of Elements tab showing the HTML structure.]

The functioning of the browser is based on the idea of depicting HTML elements as a tree.

**Document Object Model**, or **DOM**, is an Application Programming Interface (API) that enables programmatic modification of the element trees corresponding to web pages.

The JavaScript code introduced in the previous chapter used the DOM-API to add a list of notes to the page.

The following code creates a new node, assigns it to the variable `ul`, and adds some child nodes to it:

```javascript
var ul = document.createElement('ul');
ul.setAttribute('class', 'notes');

data.forEach(function(note) {
  var li = document.createElement('li');

  li.appendChild(document.createTextNode(note.content));
  ul.appendChild(li);
});
```

Finally, the tree branch of the `ul` variable is connected to its proper place in the HTML tree of the whole page:

```javascript
document.getElementById('notes').appendChild(ul);
```

### Manipulating the document object from console

The topmost node of the DOM tree of an HTML document is called the `document` object. We can perform various operations on a webpage using the DOM-API. You can access the `document` object by typing `document` into the Console tab.

![Screenshot of Console showing the document object.]

Let's add a new note to the page from the console.

First, we'll get the list of notes from the page. The list is in the first `ul` element of the page:

```javascript
list = document.getElementsByTagName('ul')[0]
```

Then create a new li-element and add some text content to it:

```javascript
newElement = document.createElement('li')
newElement.textContent = 'Page manipulation from console is easy'
```

And add the new li-element to the list:

```javascript
list.appendChild(newElement)
```

![Screenshot of the page with the new note "Page manipulation from console is easy" added at the bottom.]

Even though the page updates on your browser, the changes are not permanent. If the page is reloaded, the changes will disappear, because the changes were not pushed to the server. The JavaScript code the browser fetches will always create the list of notes based on JSON data from the address /data.json.

### CSS

The head element of the HTML code of the Notes page contains a link tag, which determines that the browser must fetch a CSS style sheet from the address main.css.

Cascading Style Sheets, or CSS, is a style sheet language used to determine the appearance of web pages.

The fetched CSS file looks as follows:

```css
.container {
  padding: 10px;
  border: 1px solid;
}

.notes {
  color: blue;
}
```

The file defines two class selectors. These are used to select certain parts of the page and to define styling rules to style them.

A class selector definition always starts with a period and contains the name of the class.

Classes are attributes, which can be added to HTML elements.

CSS attributes can be examined in the Elements tab of the console:

![Screenshot of Elements tab showing CSS styles for the .container class.]

The outermost div element has the class container. The ul element containing the list of notes has the class notes.

The CSS rule defines that elements with the container class will be outlined with a one-pixel wide border. It also sets 10-pixel padding on the element. This leaves some empty space between the element's content and the border.

The second CSS rule defines that the list of notes shall be blue.

HTML elements can also have other attributes apart from classes. The div element containing the notes has an id attribute. JavaScript code uses the id to find the element.

The Elements tab of the console can be used to change the styles of the elements.

![Screenshot of changing styles in Elements tab, e.g., changing color to red.]

Changes made on the console will not be permanent. If you want to make lasting changes, you must save the CSS file on the server.

### Loading a page containing JavaScript - review

Let's review what happens when the page [https://studies.cs.helsinki.fi/exampleapp/notes](https://studies.cs.helsinki.fi/exampleapp/notes) is opened on the browser.

![Sequence diagram for loading the notes page: 1. GET /notes -> HTML. 2. GET /main.css -> CSS. 3. GET /main.js -> JS. 4. JS executes GET /data.json -> JSON. 5. Browser renders notes.]

*   The browser fetches the HTML code defining the content and the structure of the page from the server using an HTTP GET request.
*   Links in the HTML code cause the browser to also fetch the CSS style sheet main.css...
*   ...and the JavaScript code file main.js
*   The browser executes the JavaScript code. The code makes an HTTP GET request to the address [https://studies.cs.helsinki.fi/exampleapp/data.json](https://studies.cs.helsinki.fi/exampleapp/data.json), which returns the notes as JSON data.
*   When the data has been fetched, the browser executes an event handler, which renders the notes to the page using the DOM-API.

### Forms and HTTP POST

Next, let's examine how adding a new note is done.

The Notes page contains a form element.

![Screenshot of the form in Elements tab showing action="/new_note" and method="POST".]

When the button on the form is clicked, the browser will send the user input to the server. Let's open the Network tab and see what submitting the form looks like:

![Screenshot of Network tab after submitting form showing a POST request to new_note followed by several GET requests.]

Surprisingly, submitting the form causes no fewer than five HTTP requests. The first one is the submission of the form.

![Screenshot of the POST request details showing Status Code 302 Found and Location: /notes.]

It is an HTTP POST request to the server address new_note. The server responds with HTTP status code 302. This is a URL redirect, with which the server asks the browser to do a new HTTP GET request to the address defined in the header's Location - the address /notes.

So, the browser reloads the Notes page. The reload causes three more HTTP requests: fetching the style sheet (main.css), the JavaScript code (main.js), and the notes data (data.json).

The Network tab also shows the data submitted with the form. You can view the data by first clicking the request and then opening the Payload tab:

![Screenshot of Payload tab showing Form Data: note: test.]

The Form tag has attributes action and method, which define that submitting the form is done as an HTTP POST request to the address /new_note.

![Screenshot of form tag in Elements tab.]

The code on the server responsible for the POST request is quite simple (NB: this code is on the server, and not on the JavaScript code fetched by the browser):

```javascript
app.post('/new_note', (req, res) => {
  notes.push({
    content: req.body.note,
    date: new Date(),
  })

  return res.redirect('/notes')
})
```

Data is sent as the body of the POST request.

The server can access the data by accessing the `req.body` field of the request object `req`.

The server creates a new note object, and adds it to an array called `notes`...

```javascript
notes.push({
  content: req.body.note,
  date: new Date(),
})
```

Each note object has two fields: content containing the actual content of the note, and date containing the time the note was created.

The server does not save new notes to a database, so new notes disappear when the server is restarted.

### AJAX

The Notes page of the application follows an early-90s style of web development and uses "AJAX". As such, it is on the cutting edge of early 2000s web technology.

AJAX (Asynchronous JavaScript and XML) is a term introduced in February 2005 on the back of advancements in browser technology. AJAX described a new approach to web applications that allowed fetching of content to web pages using JavaScript without the need to refetch the whole page.

Before the AJAX era, all web pages worked like the traditional web application we saw earlier in this chapter. All data shown on the page was fetched with the HTML code generated by the server.

The Notes page uses AJAX to fetch the notes data. Submitting the form still uses the traditional mechanism of HTTP POST, and the page is reloaded.

The application URLs reflect the old, carefree times. JSON data is fetched from the URL [https://studies.cs.helsinki.fi/exampleapp/data.json](https://studies.cs.helsinki.fi/exampleapp/data.json) and a new note is sent to the URL [https://studies.cs.helsinki.fi/exampleapp/new_note](https://studies.cs.helsinki.fi/exampleapp/new_note). Nowadays these URLs would not be considered very good, as they do not follow the current best practices of RESTful APIs.

The term AJAX is nowadays so commonplace that it's taken for granted. The term has faded into oblivion, and the new generation has not even heard of it.

### Single page app

In our example app, the home page works like a traditional webpage: All of the logic is on the server, and the browser only renders the HTML as instructed.

The Notes page gives some of the responsibility, generating the HTML code for existing notes, to the browser. The browser does this by executing the JavaScript code it fetched from the server. The code fetches the notes from the server as JSON data and adds HTML elements for displaying the notes to the page using the DOM-API.

In recent years, the **Single-page application** (SPA) style of creating web applications has emerged. SPA-style websites do not fetch all of their pages separately from the server like our sample application did, but instead comprise only one HTML page fetched from the server, the contents of which are manipulated with JavaScript that executes in the browser.

The Notes page of our application bears some resemblance to SPA-style apps, but it's not yet there. Even though the logic for rendering the notes is run on the browser, the page still uses the traditional way of adding new notes. The data is sent to the server through a form submit, and the server instructs the browser to reload the Notes page with a redirect.

A single-page app version of our example application can be found at [https://studies.cs.helsinki.fi/exampleapp/spa](https://studies.cs.helsinki.fi/exampleapp/spa). At first glance, the application looks exactly the same as the previous one. The HTML code is almost identical, but the JavaScript file is different (spa.js) and there is a small change in how the form-tag is defined:

![Screenshot of SPA notes page showing the HTML structure.]

The form has no action or method attributes to define how and where to send the input data.

Open the Network tab and empty it. When you now create a new note, you'll notice that the browser sends only one request to the server.

![Screenshot of Network tab for SPA showing a single POST request to new_note_spa.]

The POST request to the address new_note_spa contains the new note as JSON data containing both the content of the note (content) and the timestamp (date):

```json
{
  "content": "single page app does not reload the whole page",
  "date": "2019-01-18T15:19:08.981Z"
}
```

The Content-Type header of the request tells the server that the included data is represented in JSON format:

![Screenshot of Request Headers showing Content-Type: application/json.]

Without this header, the server would not know how to correctly parse the data.

The server responds with status code 201 created. This time the server does not ask for a redirect, the browser stays on the same page, and it sends no further HTTP requests.

The SPA version of the app does not traditionally send the form data, but instead uses the JavaScript code it fetched from the server. We'll look into this code a bit, even though understanding all the details of it is not important just yet.

```javascript
var form = document.getElementById('notes_form')

form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}
```

The command `document.getElementById('notes_form')` instructs the code to fetch the form element from the page, and to register an event handler to handle the form's submit event. The event handler immediately calls the method `e.preventDefault()` to prevent the default handling of form's submit. The default method would send the data to the server and cause a GET request, which we don't want to happen.

Then the event handler creates a note, adds it to the notes list with the command `notes.push(note)`, rerenders the note list on the page, and sends the new note to the server.

The code for sending the note to the server is as follows:

```javascript
var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...
  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader('Content-type', 'application/json')
  xhttpForPost.send(JSON.stringify(note))
}
```

The code determines that the data is to be sent with an HTTP POST request and the data type is to be JSON. The data type is determined with a Content-type header. Then the data is sent as a JSON string.

The application code is available at [https://github.com/mluukkai/example_app](https://github.com/mluukkai/example_app). It's worth remembering that the application is only meant to demonstrate the concepts of the course. The code follows a poor style of development in some measure, and should not be used as a model for your own applications. The same applies to the URLs used. The use of the name new_note_spa that new notes are sent to, does not adhere to current best practices.

### JavaScript-libraries

The sample application is done with so-called vanilla JavaScript, using only the DOM-API and JavaScript to manipulate the structure of the pages.

Instead of using only JavaScript and the DOM-API, different libraries containing tools that are easier to work with compared to the DOM-API are often used to manipulate pages. One of these libraries is the very popular jQuery.

jQuery was developed back when web applications mainly followed the traditional style of the server forming HTML pages, the functionality of which was enhanced on the browser side with JavaScript. One of the reasons for jQuery's success was its so-called cross-browser compatibility. The library worked regardless of the browser or the manufacturer, so there was no need for browser-specific solutions. Nowadays there is no longer as much need for jQuery as there was in the past, and the most popular browsers generally support basic functionalities well.

The rise of the single-page application brought several more "modern" ways of web development than jQuery. The first favorite of the wave of developers was BackboneJS. After its launch in 2012, Google's AngularJS quickly became the de facto standard of modern web development.

However, the popularity of Angular plummeted in October 2014 after the Angular team announced that support for version 1 will end, and that Angular 2 will not be backwards compatible with the first version. Angular 2 and the newer versions have not been received with too much enthusiasm.

Currently, the most popular tool for implementing the browser-side logic of web applications is Facebook's React library. During this course, we will get familiar with React and the Redux library, which are frequently used together.

React's position looks strong, but the world of JavaScript is constantly changing. For example, recently a newcomer - VueJS - has been capturing some interest.

### Full-stack web development

What does full-stack web development mean? Full-stack is a buzzword that everyone talks about, but no one knows what it means. Or at least, there is no agreed-upon definition for it.

Practically all web applications have (at least) two "layers": the browser, being closer to the user, is the top layer, and the server is the bottom layer. There is often also a database layer below the server. We can therefore think of the architecture of a web application as a stack of layers.

Often, we also talk about the frontend and the backend. The browser is the frontend, and the JavaScript that runs in the browser is frontend code. The server on the other hand is the backend.

In the context of this course, full-stack web development means that we focus on all parts of the application: the frontend, the backend, and the database. Sometimes the software on the server and its operating system are seen as parts of the stack, but we won't go into those.

We will program the backend with JavaScript, using the Node.js runtime environment. Using the same programming language on multiple layers of the stack gives full-stack web development a whole new dimension. However, it's not a requirement of full-stack web development to use the same programming language (JavaScript) for all layers of the stack.

It used to be more common for developers to specialize in one layer of the stack, for example, the backend. However, because it has become common for developers to be proficient in all layers of the stack, it has become common for developers to be proficient in all layers of the stack. In job advertisements, a full-stack developer is expected to know everything about the frontend and backend, and often also about the databases. Sometimes there are also deployment and configuration administration skills to operate their application, for example, in the cloud.

### JavaScript fatigue

Full-stack web development is challenging in many ways. Things are happening in many places at once, and debugging is quite a bit harder than with regular desktop applications. JavaScript does not always work as you'd expect it to (compared to many other languages), and the asynchronous way its runtime environments work causes all sorts of challenges. Communicating on the web requires knowledge of the HTTP protocol. One must also handle databases and server administration and configuration. It's also good to know enough CSS to make the applications at least somewhat presentable.

The world of JavaScript development, which brings with it its own set of challenges, tools, libraries, and even the language itself, is in a state of constant change. People started to talk about JavaScript fatigue, and have coined a term for it: **JavaScript fatigue**. See more in Medium or this blog post.

You will suffer from JavaScript fatigue yourself during this course. Fortunately, for us, there are several ways to tame the fatigue, and we can start with the most important one: the configuration. We can't avoid configuration completely, but we can mainly push ahead in the course without having to worry about the configuration too much.
